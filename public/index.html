<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge NLP Chat</title>
  <!-- Import ethers.js v5 required for Stargate Protocol -->
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
  <!-- Add Stargate SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@layerzerolabs/stargate-ui@latest/element.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f7fa;
      color: #333;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .header {
      background-color: #3B48DF;
      color: white;
      padding: 20px 0;
      border-radius: 10px 10px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
    }
    
    .header h1 {
      margin: 0;
    }
    
    .wallet-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .wallet-button {
      background-color: white;
      color: #3B48DF;
      border: none;
      border-radius: 30px;
      padding: 8px 15px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-weight: bold;
    }
    
    .wallet-button:hover {
      background-color: #f0f0f0;
    }
    
    .wallet-info {
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 5px 10px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .wallet-info .balance {
      font-weight: bold;
    }
    
    .wallet-info .address {
      font-family: monospace;
    }
    
    .chat-container {
      background-color: white;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      height: 500px;
      display: flex;
      flex-direction: column;
    }
    
    .chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding: 10px;
    }
    
    .message {
      margin-bottom: 15px;
      padding: 10px 15px;
      border-radius: 20px;
      max-width: 80%;
      line-height: 1.4;
      position: relative;
    }
    
    .user-message {
      align-self: flex-end;
      background-color: #3B48DF;
      color: white;
      margin-left: auto;
    }
    
    .system-message {
      align-self: flex-start;
      background-color: #F0F2F5;
      color: #333;
    }
    
    .message-input {
      display: flex;
      gap: 10px;
    }
    
    input[type="text"] {
      flex-grow: 1;
      padding: 12px 15px;
      border: 1px solid #ddd;
      border-radius: 30px;
      font-size: 16px;
      outline: none;
    }
    
    button {
      background-color: #3B48DF;
      color: white;
      border: none;
      border-radius: 30px;
      padding: 12px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #2D3AC3;
    }
    
    .examples {
      margin-top: 20px;
      background-color: #F0F2F5;
      border-radius: 10px;
      padding: 15px;
    }
    
    .examples h3 {
      margin-top: 0;
      margin-bottom: 10px;
    }
    
    .examples ul {
      margin: 0;
      padding-left: 20px;
    }
    
    .examples li {
      margin-bottom: 5px;
      cursor: pointer;
      color: #3B48DF;
    }
    
    .notification {
      background-color: #10B981;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      animation: fadeOut 5s forwards;
    }
    
    @keyframes fadeOut {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; display: none; }
    }
    
    pre {
      background-color: #F0F2F5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 14px;
    }
    
    .transaction-status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }
    
    .transaction-pending {
      background-color: #FEF3C7;
      color: #92400E;
    }
    
    .transaction-success {
      background-color: #D1FAE5;
      color: #065F46;
    }
    
    .transaction-error {
      background-color: #FEE2E2;
      color: #B91C1C;
    }
    
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s linear 0.25s, opacity 0.25s 0s;
    }
    
    .modal.open {
      visibility: visible;
      opacity: 1;
      transition-delay: 0s;
    }
    
    .modal-content {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .modal-header h2 {
      margin: 0;
      font-size: 20px;
    }
    
    .modal-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 24px;
      color: #6B7280;
      padding: 0;
    }
    
    .modal-body {
      margin-bottom: 20px;
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Natural Language Bridge</h1>
      <div class="wallet-section">
        <div id="wallet-info" style="display: none;" class="wallet-info">
          <span class="balance" id="wallet-balance">0 ETH</span>
          <span class="address" id="wallet-address">0x1234...5678</span>
        </div>
        <button id="connect-wallet" class="wallet-button">Connect Wallet</button>
        <button id="disconnect-wallet" class="wallet-button" style="display: none;">Disconnect</button>
      </div>
    </div>
    
    <div class="chat-container">
      <div class="chat-messages" id="chat-messages">
        <div class="message system-message">
          Hello! I can help you bridge tokens between chains using natural language. Try saying something like "Send 100 USDC to Arbitrum" or "Bridge ETH from Ethereum to Base".
        </div>
      </div>
      
      <div class="message-input">
        <input type="text" id="command-input" placeholder="Type your bridge command here..." autofocus>
        <button id="send-button">Send</button>
      </div>
    </div>
    
    <div class="examples">
      <h3>Example commands:</h3>
      <ul>
        <li class="example-command">Bridge 10 USDC to Arbitrum</li>
        <li class="example-command">Send 0.5 ETH from Ethereum to Optimism</li>
        <li class="example-command">Transfer 50 USDT to Polygon with fast gas</li>
      </ul>
    </div>
  </div>
  
  <!-- Transaction confirmation modal -->
  <div id="transaction-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Confirm Transaction</h2>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body" id="transaction-details">
        <!-- Transaction details will be inserted here -->
      </div>
      <div class="modal-footer">
        <button id="cancel-transaction">Cancel</button>
        <button id="confirm-transaction">Confirm</button>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Add welcome message
      addSystemMessage("Hello! I can help you bridge tokens between chains using natural language. Try saying something like \"Send 100 USDC to Arbitrum\" or \"Bridge ETH from Ethereum to Base\".");
      
      // Add console log to show if wallet is detected
      console.log('Checking for wallet...');
      if (window.ethereum) {
        console.log('Wallet detected!');
        checkConnection();
      } else {
        console.log('No wallet detected');
        addSystemMessage("No wallet detected. Please install MetaMask or another Ethereum wallet to use this app.", "transaction-error");
      }
      
      const chatMessages = document.getElementById('chat-messages');
      const commandInput = document.getElementById('command-input');
      const sendButton = document.getElementById('send-button');
      const exampleCommands = document.querySelectorAll('.example-command');
      const connectButton = document.getElementById('connect-wallet');
      const disconnectButton = document.getElementById('disconnect-wallet');
      const walletInfo = document.getElementById('wallet-info');
      const walletAddress = document.getElementById('wallet-address');
      const walletBalance = document.getElementById('wallet-balance');
      
      // Check for wallet and show appropriate message
      if (!window.ethereum) {
        console.warn('No Ethereum wallet detected');
        // Add a message to the chat
        const messageElement = document.createElement('div');
        messageElement.className = 'message system-message';
        messageElement.innerHTML = 'No Ethereum wallet detected. Please install <a href="https://metamask.io/" target="_blank">MetaMask</a> or another Ethereum wallet to use the wallet connection features.';
        chatMessages.appendChild(messageElement);
        
        // Also update the connect button
        connectButton.textContent = 'Install Wallet';
        connectButton.addEventListener('click', function() {
          window.open('https://metamask.io/', '_blank');
        }, { once: true }); // Remove the original click handler
      }
      
      // Transaction modal elements
      const transactionModal = document.getElementById('transaction-modal');
      const modalClose = document.getElementById('modal-close');
      const cancelTransaction = document.getElementById('cancel-transaction');
      const confirmTransaction = document.getElementById('confirm-transaction');
      const transactionDetails = document.getElementById('transaction-details');
      
      let currentTransaction = null;
      let currentAccount = null;
      let walletClient = null;
      
      // Configure wagmi
      const config = window.wagmi?.createConfig ? window.wagmi.createConfig({
        chains: [
          window.chains.mainnet,
          window.chains.base,
          window.chains.optimism,
          window.chains.arbitrum,
          window.chains.polygon
        ],
        transports: {
          [window.chains.mainnet.id]: window.viem?.http ? window.viem.http() : null,
          [window.chains.base.id]: window.viem?.http ? window.viem.http() : null,
          [window.chains.optimism.id]: window.viem?.http ? window.viem.http() : null,
          [window.chains.arbitrum.id]: window.viem?.http ? window.viem.http() : null,
          [window.chains.polygon.id]: window.viem?.http ? window.viem.http() : null
        }
      }) : null;
      
      // Watch for account changes if wagmi is available
      let unwatch;
      if (window.wagmi?.watchAccount && config) {
        unwatch = window.wagmi.watchAccount(config, {
          onChange(account) {
            handleAccountChange(account);
          }
        });
      }
      
      // Listen for account changes directly from ethereum provider
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', (accounts) => {
          console.log('accountsChanged event triggered:', accounts);
          if (accounts.length > 0) {
            currentAccount = {
              address: accounts[0],
              isConnected: true
            };
          } else {
            currentAccount = {
              isConnected: false
            };
          }
          handleAccountChange(currentAccount);
        });
      }
      
      // Handle account change
      function handleAccountChange(account) {
        currentAccount = account;
        
        if (account.isConnected) {
          connectButton.style.display = 'none';
          disconnectButton.style.display = 'block';
          walletInfo.style.display = 'flex';
          
          // Format address
          const address = account.address;
          const formattedAddress = `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
          walletAddress.textContent = formattedAddress;
          
          // Get balance
          fetchBalance(account.address);
          
          // Create wallet client for transactions
          createWalletClient();
          
          // Add system message about connection
          addMessage(`Connected to wallet ${formattedAddress}. You can now bridge tokens!`, 'system');
        } else {
          connectButton.style.display = 'block';
          disconnectButton.style.display = 'none';
          walletInfo.style.display = 'none';
          walletBalance.textContent = '0 ETH';
          walletAddress.textContent = '';
          walletClient = null;
        }
      }
      
      // Create wallet client
      async function createWalletClient() {
        try {
          if (window.ethereum) {
            walletClient = window.viem.createWalletClient({
              account: currentAccount.address,
              transport: window.viem.custom(window.ethereum)
            });
          }
        } catch (error) {
          console.error('Error creating wallet client:', error);
        }
      }
      
      // Fetch wallet balance
      async function fetchBalance(address) {
        try {
          // For this example, just use a simple fetch to an API endpoint
          // In a real app, you'd use viem's getBalance or a similar function
          fetch(`/api/balance?address=${address}`)
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                walletBalance.textContent = `${data.balance} ETH`;
              }
            })
            .catch(error => {
              console.error('Error fetching balance:', error);
              walletBalance.textContent = 'Error';
            });
        } catch (error) {
          console.error('Error fetching balance:', error);
          walletBalance.textContent = 'Error';
        }
      }
      
      // Connect wallet
      connectButton.addEventListener('click', async () => {
        try {
          console.log('Connect button clicked');
          console.log('window.ethereum exists:', !!window.ethereum);
          
          if (!window.ethereum) {
            throw new Error('No wallet found. Please install MetaMask or another Ethereum wallet.');
          }
          
          // Add system message about connection attempt
          addMessage('Attempting to connect to wallet...', 'system');
          
          // Request account access directly from provider
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          console.log('Accounts:', accounts);
          
          if (accounts && accounts.length > 0) {
            // Set current account
            currentAccount = {
              address: accounts[0],
              isConnected: true
            };
            
            handleAccountChange(currentAccount);
          } else {
            throw new Error('No accounts found after connection');
          }
        } catch (error) {
          console.error('Error connecting wallet:', error);
          addMessage(`Error connecting wallet: ${error.message}. Make sure you have MetaMask or another Ethereum wallet installed.`, 'system');
        }
      });
      
      // Disconnect wallet
      disconnectButton.addEventListener('click', async () => {
        try {
          await window.wagmi.disconnect(config);
          addMessage('Wallet disconnected.', 'system');
        } catch (error) {
          console.error('Error disconnecting wallet:', error);
        }
      });
      
      // Add event listeners
      sendButton.addEventListener('click', handleSendMessage);
      
      commandInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleSendMessage();
        }
      });
      
      // Example command click handler
      exampleCommands.forEach(command => {
        command.addEventListener('click', function() {
          commandInput.value = this.textContent;
          commandInput.focus();
        });
      });
      
      // Modal event listeners
      modalClose.addEventListener('click', closeModal);
      cancelTransaction.addEventListener('click', closeModal);
      confirmTransaction.addEventListener('click', executeTransaction);
      
      // Close modal
      function closeModal() {
        transactionModal.classList.remove('open');
        currentTransaction = null;
      }
      
      // Open modal with transaction details
      function openTransactionModal(transaction) {
        if (!transaction) {
          console.error('Attempted to open transaction modal with no transaction data');
          return;
        }
        
        // Ensure all required fields exist
        if (!transaction.sourceChain || !transaction.destinationChain || !transaction.token) {
          console.error('Transaction missing required fields', transaction);
          addMessage('Cannot process transaction: missing required information', 'system');
          return;
        }
        
        // Clone transaction to prevent reference issues
        currentTransaction = {...transaction};
        
        // Set default gas preference if not present
        if (!currentTransaction.gasPreference) {
          currentTransaction.gasPreference = 'normal';
        }
        
        // Check if Stargate supports this route
        const isStargateSupported = checkStargateSupport(currentTransaction.sourceChain, 
          currentTransaction.destinationChain, 
          currentTransaction.token);
        
        // Format transaction details for display
        const details = `
          <div>
            <p><strong>Operation:</strong> Bridge tokens</p>
            <p><strong>Source Chain:</strong> ${currentTransaction.sourceChain}</p>
            <p><strong>Destination Chain:</strong> ${currentTransaction.destinationChain}</p>
            <p><strong>Token:</strong> ${currentTransaction.token}</p>
            <p><strong>Amount:</strong> ${currentTransaction.amount || '0'}</p>
            <p><strong>Gas Preference:</strong> ${currentTransaction.gasPreference}</p>
            ${isStargateSupported ? 
              '<p><strong>Bridge Provider:</strong> <span style="color: #3B48DF;">Stargate Protocol</span></p>' : 
              '<p><strong>Note:</strong> <span style="color: #EF4444;">This route may not be supported by Stargate</span></p>'}
          </div>
        `;
        
        transactionDetails.innerHTML = details;
        transactionModal.classList.add('open');
        
        console.log('Transaction modal opened with data:', currentTransaction);
      }
      
      // Check if Stargate supports this route
      function checkStargateSupport(sourceChain, destinationChain, token) {
        // Convert to lowercase for comparison
        const src = sourceChain.toLowerCase();
        const dst = destinationChain.toLowerCase();
        const tkn = token.toLowerCase();
        
        // Define supported chains
        const supportedChains = ['ethereum', 'base', 'optimism', 'arbitrum', 'polygon'];
        
        // Define supported tokens
        const supportedTokens = ['eth', 'usdc', 'usdt'];
        
        // Check if chains and token are supported
        if (!supportedChains.includes(src) || !supportedChains.includes(dst)) {
          return false;
        }
        
        if (!supportedTokens.includes(tkn)) {
          return false;
        }
        
        // Special case: ETH is not supported on Polygon via Stargate
        if (tkn === 'eth' && (src === 'polygon' || dst === 'polygon')) {
          return false;
        }
        
        return true;
      }
      
      // Execute transaction
      async function executeTransaction() {
        if (!currentTransaction) {
          console.warn('No current transaction to execute');
          return;
        }
        
        if (!currentAccount || !currentAccount.isConnected) {
          closeModal();
          addMessage('Please connect your wallet first.', 'system');
          return;
        }
        
        // Store transaction locally so it's not affected by closeModal
        const transaction = {...currentTransaction};
        
        // Show pending status
        closeModal();
        const statusMessage = addMessage('Processing your transaction...', 'system');
        statusMessage.classList.add('transaction-pending');
        
        try {
          // Add gas preference if not present
          if (!transaction.gasPreference) {
            transaction.gasPreference = 'normal';
          }
          
          // Call the backend API for the bridging parameters
          const response = await fetch('/api/execute-bridge', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              ...transaction,
              walletAddress: currentAccount.address
            })
          });
          
          if (!response.ok) {
            // Handle HTTP errors
            const errorText = await response.text();
            console.error('Server error:', response.status, errorText);
            throw new Error(`Server returned ${response.status}: ${errorText || 'Unknown error'}`);
          }
          
          const data = await response.json();
          
          if (data.success) {
            // For test mode transactions, show success directly
            if (data.testMode) {
              statusMessage.classList.remove('transaction-pending');
              statusMessage.classList.add('transaction-success');
              statusMessage.innerHTML = `Transaction successful (Test Mode)! <a href="${data.txExplorerUrl}" target="_blank">View on block explorer</a>`;
              return;
            }
            
            // Normal success flow here if not test mode
            statusMessage.classList.remove('transaction-pending');
            statusMessage.classList.add('transaction-success');
            statusMessage.innerHTML = `Transaction successful! <a href="${data.txExplorerUrl}" target="_blank">View on block explorer</a>`;
          } 
          else if (data.useStargate) {
            // Handle Stargate Protocol direct interaction
            try {
              statusMessage.innerHTML = "Preparing Stargate transaction...";
              
              // Get the parameters from the backend
              const params = data.implementationStatus;
              
              // We need the provider from the user's wallet
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              
              // Stargate Router ABI (minimal for swap function)
              const stargateRouterABI = [
                "function swap(uint16 _dstChainId, uint256 _srcPoolId, uint256 _dstPoolId, address payable _refundAddress, uint256 _amountLD, uint256 _minAmountLD, uint256 _lzTxParams, bytes calldata _to, bytes calldata _payload) payable external",
                "function quoteLayerZeroFee(uint16 _dstChainId, uint8 _functionType, bytes calldata _toAddress, bytes calldata _transferAndCallPayload, uint256 _lzTxParams) external view returns (uint256, uint256)"
              ];
              
              // Create contract interface for Stargate Router
              const routerAddress = params.stargateRouterAddress;
              const stargateRouter = new ethers.Contract(routerAddress, stargateRouterABI, signer);
              
              // Convert wallet address to bytes format for the destination
              const addressToBytes = function(addr) {
                return ethers.utils.defaultAbiCoder.encode(['address'], [addr]);
              };
              
              // Prepare parameters for the swap call
              const dstChainId = params.destChainId;
              const srcPoolId = params.srcPoolId;
              const dstPoolId = params.dstPoolId;
              const refundAddress = currentAccount.address;
              const amountLD = params.amountWithDecimals;
              const slippage = 0.005; // 0.5% slippage allowance
              const minAmountLD = ethers.BigNumber.from(amountLD)
                .mul(ethers.BigNumber.from(10000 - Math.floor(slippage * 10000)))
                .div(ethers.BigNumber.from(10000));
              
              const lzTxParams = 0; // Default params
              const to = addressToBytes(currentAccount.address);
              const payload = '0x'; // Empty payload
              
              // First we need to estimate the LayerZero fee
              statusMessage.innerHTML = "Estimating cross-chain fee...";
              
              // Request the quote from the contract
              const [nativeFee, zroFee] = await stargateRouter.quoteLayerZeroFee(
                dstChainId,
                1, // function type for swap
                to,
                payload,
                lzTxParams
              );
              
              statusMessage.innerHTML = `Initiating Stargate bridge transaction... (Fee: ${ethers.utils.formatEther(nativeFee)} ETH)`;
              
              // Check if we're dealing with a token that requires approval
              if (params.token.toLowerCase() !== 'eth') {
                // For ERC20 tokens, we need to approve the Stargate Router first
                statusMessage.innerHTML = "Checking token approval...";
                
                const tokenABI = [
                  "function approve(address spender, uint256 amount) external returns (bool)",
                  "function allowance(address owner, address spender) external view returns (uint256)"
                ];
                
                const tokenAddress = data.implementationStatus.tokenAddress;
                const tokenContract = new ethers.Contract(tokenAddress, tokenABI, signer);
                
                // Check current allowance
                const allowance = await tokenContract.allowance(currentAccount.address, routerAddress);
                
                if (allowance.lt(ethers.BigNumber.from(amountLD))) {
                  statusMessage.innerHTML = "Approving tokens for bridge transfer...";
                  
                  // Request approval
                  const approveTx = await tokenContract.approve(
                    routerAddress,
                    ethers.constants.MaxUint256 // Approve max amount for efficient future transactions
                  );
                  
                  statusMessage.innerHTML = "Waiting for approval transaction...";
                  await approveTx.wait();
                  statusMessage.innerHTML = "Token approval confirmed! Proceeding with bridge...";
                }
              }
              
              // Send the transaction
              let tx;
              if (params.token.toLowerCase() === 'eth') {
                // For ETH, we need to send value with the transaction
                tx = await stargateRouter.swap(
                  dstChainId,
                  srcPoolId,
                  dstPoolId,
                  refundAddress,
                  amountLD,
                  minAmountLD,
                  lzTxParams,
                  to,
                  payload,
                  { value: nativeFee }
                );
              } else {
                // For ERC20 tokens
                tx = await stargateRouter.swap(
                  dstChainId,
                  srcPoolId,
                  dstPoolId,
                  refundAddress,
                  amountLD,
                  minAmountLD,
                  lzTxParams,
                  to,
                  payload,
                  { value: nativeFee }
                );
              }
              
              statusMessage.innerHTML = "Transaction submitted! Waiting for confirmation...";
              
              // Wait for transaction to be mined
              const receipt = await tx.wait();
              
              // Determine the explorer URL
              let explorerUrl = '';
              switch (params.sourceChain) {
                case 'ethereum':
                  explorerUrl = `https://etherscan.io/tx/${receipt.transactionHash}`;
                  break;
                case 'base':
                  explorerUrl = `https://basescan.org/tx/${receipt.transactionHash}`;
                  break;
                case 'optimism':
                  explorerUrl = `https://optimistic.etherscan.io/tx/${receipt.transactionHash}`;
                  break;
                case 'arbitrum':
                  explorerUrl = `https://arbiscan.io/tx/${receipt.transactionHash}`;
                  break;
                case 'polygon':
                  explorerUrl = `https://polygonscan.com/tx/${receipt.transactionHash}`;
                  break;
                default:
                  explorerUrl = `https://etherscan.io/tx/${receipt.transactionHash}`;
              }
              
              statusMessage.classList.remove('transaction-pending');
              statusMessage.classList.add('transaction-success');
              statusMessage.innerHTML = `Stargate bridge transaction confirmed! <a href="${explorerUrl}" target="_blank">View on block explorer</a><br>
                <small>Note: It may take a few minutes for funds to appear on the destination chain.</small>`;
              
            } catch (stargateError) {
              console.error('Stargate transaction error:', stargateError);
              statusMessage.classList.remove('transaction-pending');
              statusMessage.classList.add('transaction-error');
              
              // User rejected transaction
              if (stargateError.code === 4001) {
                statusMessage.innerHTML = `<strong>Transaction cancelled:</strong> You rejected the transaction.`;
                return;
              }
              
              // Gas estimation failed - likely insufficient funds for gas
              if (stargateError.code === -32603) {
                statusMessage.innerHTML = `<strong>Transaction failed:</strong> Insufficient funds for gas fees.`;
                return;
              }
              
              statusMessage.innerHTML = `<strong>Stargate transaction failed:</strong> ${stargateError.message || 'Unknown error'}<br>
                <small>This could be due to insufficient funds, slippage issues, or network congestion.</small>`;
            }
          } else {
            statusMessage.classList.remove('transaction-pending');
            statusMessage.classList.add('transaction-error');
            
            // Different handling for different error types
            if (data.implementationStatus) {
              // This is the case for real transactions that are in progress of being implemented
              const details = JSON.stringify(data.implementationStatus, null, 2);
              statusMessage.innerHTML = `<strong>${data.message}:</strong> ${data.error}<br>
                <details>
                  <summary>Transaction Details</summary>
                  <pre>${details}</pre>
                </details>`;
            } else if (data.testAmountRequired) {
              // This is the test mode requirement error
              statusMessage.innerHTML = `<strong>Transaction failed:</strong> ${data.error}`;
            } else {
              // Generic error
              statusMessage.textContent = `Transaction failed: ${data.error || 'Unknown error'}`;
            }
          }
        } catch (error) {
          console.error('Error executing transaction:', error);
          statusMessage.classList.remove('transaction-pending');
          statusMessage.classList.add('transaction-error');
          statusMessage.textContent = `Transaction failed: ${error.message || 'Could not connect to the server'}`;
        }
      }
      
      // Handle sending a message
      function handleSendMessage() {
        const messageText = commandInput.value.trim();
        
        if (messageText === '') return;
        
        // Add user message to the chat
        addMessage(messageText, 'user');
        
        // Clear input field
        commandInput.value = '';
        
        // Process the command
        processCommand(messageText);
      }
      
      // Process the user's command
      async function processCommand(command) {
        loadingIndicator.style.display = 'block';
        
        try {
          const response = await fetch('/api/process-command', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              command,
              walletAddress: currentAccount.address
            })
          });
          
          const data = await response.json();
          
          // Display response
          addSystemMessage(data.message);
          
          // Check if we have a transaction
          if (data.transaction) {
            currentTransaction = data.transaction;
            showConfirmationModal(data.transaction);
          }
        } catch (error) {
          console.error('Error processing command:', error);
          addSystemMessage(`Error: ${error.message || 'Could not process your command.'}`, 'transaction-error');
        } finally {
          loadingIndicator.style.display = 'none';
        }
      }
      
      // Helper function to add messages to the chat
      function addMessage(text, type) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${type}-message`;
        messageElement.innerHTML = text;
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return messageElement;
      }
      
      function addSystemMessage(text, className = "") {
        const messageElement = document.createElement('div');
        messageElement.className = `message system-message ${className}`;
        messageElement.innerHTML = text;
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return messageElement;
      }
      
      // Initialize account state
      if (window.ethereum) {
        window.ethereum.request({ method: 'eth_accounts' })
          .then(accounts => {
            console.log('Initial accounts:', accounts);
            if (accounts && accounts.length > 0) {
              currentAccount = {
                address: accounts[0],
                isConnected: true
              };
              handleAccountChange(currentAccount);
            }
          })
          .catch(error => {
            console.error('Error getting initial accounts:', error);
          });
      } else {
        console.log('No ethereum provider detected during initialization');
      }
    });
  </script>
</body>
</html> 